## [144. Binary Tree Preorder Traversal](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

[Решение Python](https://leetcode.com/problems/binary-tree-preorder-traversal/submissions/989075817/)

Учитывая root двоичного дерева, верните префиксный обход его узлов.

**Example 1:**

Входные данные: root = [1,null, 2,3]

Выходной сигнал: [1,2,3]

**Example 2:**

Входные данные: корень = [1, 2, 3, 4, 5, null, 8, null, null, 6, 7, 9]

Вывод: [1,2,4,5,6,7,3,8,9]

**Example 3:**

Ввод: root = []

Выходной сигнал: []

**Example 4:**

Ввод: root = [1]

Выходной сигнал: [1]

Constraints:

* Количество узлов в дереве находится в диапазоне [0, 100].
* -100 <= Node.val <= 100

### Complexity
Time complexity: O(n)

Memory complexity: O(h), где h - высота дерева (самое большое расстояние от корня до листа), в худшем случае h = n (бамбук), поэтому можно сказать что mem: O(n). Если входными ограничениями задана высота дерева (например 1024 узла), то валидно говорить, что по памяти константа O(h) = O(1024) = O(1). 

### Пояснения
Pre order - значит перед тем как рекурсивно идти в левое и правое поддерево добавляем значение узла в ответ.
Обычно рекурсивного решения достаточно в реальных интервью.