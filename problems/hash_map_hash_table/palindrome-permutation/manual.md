## [Перестановка букв](https://algocode.io/courses/algo-big-tech/problem/palindrome-permutation)

Дана строка s. Нужно вернуть true, если после перестановки символов в строке может получится палиндром, и false в противном случае.

Палиндром — это строка, которая читается одинаково слева направо и справа налево.

Пример 1:

Ввод: s="cabab"
Вывод: true
Объяснение: можно переставить буквы и получить палиндром "abcba" или "bacab"
Пример 2:

Ввод: s="hello"
Вывод: false
Ограничения:

Строка s содержит только английские буквы в нижнем регистре.
len(s) >= 1

## Решение

1. Создаем пустой словарь `char_count` для хранения количества вхождений каждого символа в строке.
2. Итерируемся по каждому символу `char` в строке `s`.
3. Если `char` уже есть в словаре `char_count`, увеличиваем его значение на 1. Если `char` нет в словаре, добавляем его со значением 1.
4. Создаем переменную `odd_count` и устанавливаем ее в 0. Она будет хранить количество символов с нечетным количеством вхождений.
5. Итерируемся по значениям в словаре `char_count`.
6. Если значение `count` нечетное, увеличиваем `odd_count` на 1.
7. Если `odd_count` больше 1, возвращаем `false`, так как палиндром может содержать не более одного символа с нечетным количеством вхождений.
8. Если `odd_count` меньше или равно 1, возвращаем `true`, так как палиндром может быть составлен из символов с четным количеством вхождений и не более одного символа с нечетным количеством вхождений.
9. Конец алгоритма.

## Решение моё
- Читаю задачу вслух
- Понимаю условие, задаю вопросы по условию
- Придумываю ещё примеры краевые случаи
- РИСУЮ НЕ решение, а условие! По возможности, рассказываю идею как буду решать.
- Оценить решение по времени и памяти
- Написать код
- Проверка синтаксиса
- Проверка логики - отладка без запуска

Ограничения:
s = ['a-z'] -> всего может быть 26 символов.
strlen(1...N)

ИДЕЯ:
Подсчет букв: TRUE в том случае, если в массиве только 1 буква встречается
1 раз (char <= 1). Буква с четным количеством либо 0 пропускаем.
Остаток от деления будет давать 0 или 1.
Используем ord($char) - ord('a'), чтобы получить индекс массива
Количество 1 буквы делим по модулю на 2 и оплучам либо 0 либо 1
ord('a') => 1
ord('b') => 0
ord('c') => 1
ord('d') => 0

суммируем все значения в массиве count и возвращаем sum <= 1.

Time: O(n)
Mem: O(1)